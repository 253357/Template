# 数学

## 多项式

### FFT

$n$ 需补成 $2$ 的幂 （ $n$ 必须超过 $a$ 和 $b$ 的最高指数之和）

```c++
typedef double LD;
const LD PI=acos(-1);
struct C
{
    LD r,i;
    C(LD r=0,LD i=0):r(r),i(i){}
};
C operator + (const C& a, const C& b){
    return C(a.r+b.r,a.i+b.i);
}
C operator - (const C& a, const C& b){
    return C(a.r-b.r,a.i-b.i);
}
C operator * (const C& a, const C& b){
    return C(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);
}
 
void FFT(C x[],int n,int p)
{
    for (int i=0,t=0;i<n;++i)
    {
        if (i>t) swap(x[i],x[t]);
        for (int j=n>>1;(t^=j)<j;j>>=1);
    }
    for (int h=2;h<=n;h<<=1)
    {
        C wn(cos(p*2*PI/h),sin(p*2*PI/h));
        for (int i=0;i<n;i+=h)
        {
            C w(1,0),u;
            for (int j=i,k=h>>1;j<i+k;++j)
            {
                u=x[j+k]*w;
                x[j+k]=x[j]-u;
                x[j]=x[j]+u;
                w=w*wn;
            }
        }
    }
    if (p==-1)
        for (int i=0;i<n;i++) x[i].r/=n;
}
 
void conv(C a[], C b[], int n) {
    FFT(a,n,1);
    FFT(b,n,1);
    for (int i=0;i<n;i++)
        a[i]=a[i]*b[i];
    FFT(a,n,-1);
}
```

### NTT

$n$ 需补成 $2$ 的幂 （ $n$ 必须超过 $a$ 和 $b$ 的最高指数之和）

* 先进行 NTT_init() 操作， $G$ 为 $MOD$ 原根

NTT 素数表及对应原根

| MOD | G |
| --- | --- |
| 40961 | 3 |
| 65537 | 3 |
| 786433 | 10 |
| 5767169 | 3 |
| 7340033 | 3 |
| 23068673 | 3 |
| 104857601 | 3 |
| 167772161 | 3 |
| 469762049 | 3 |
| 998244353 | 3 |
| 1004535809 | 3 |
| 2013265921 | 31 |
| 2281701377 | 3 |
| 3221225473 | 5 |
| 75161927681 | 3 |

```c++
#define MOD 998244353
#define G 3

const int N=2000010;

LL bin(LL x,LL n,LL mo)
{
    LL ret=mo!=1;
    for (x%=mo;n;n>>=1,x=x*x%mo)
        if (n&1) ret=ret*x%mo;
    return ret;
}

inline LL get_inv(LL x,LL p)
{
    return bin(x,p-2,p);
}

LL wn[N<<1],rev[N<<1];
int NTT_init(int n_)
{
    int step=0,n=1;
    for (;n<n_;n<<=1) step++;
    for (int i=1;i<n;i++)
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(step-1));
    int g=bin(G,(MOD-1)/n,MOD);
    wn[0]=1;
    for (int i=1;i<=n;i++)
        wn[i]=wn[i-1]*g%MOD;
    return n;
}

void NTT(LL a[],int n,int f)
{
    for (int i=0;i<n;i++)
        if (i<rev[i]) swap(a[i],a[rev[i]]);
    for (int k=1;k<n;k<<=1)
    {
        for (int i=0;i<n;i+=(k<<1))
        {
            int t=n/(k<<1);
            for (int j=0;j<k;j++)
            {
                LL w=f==1?wn[t*j]:wn[n-t*j];
                LL x=a[i+j];
                LL y=a[i+j+k]*w%MOD;
                a[i+j]=(x+y)%MOD;
                a[i+j+k]=(x-y+MOD)%MOD;
            }
        }
    }
    if (f==-1)
    {
        LL ninv=get_inv(n,MOD);
        for (int i=0;i<n;i++)
            a[i]=a[i]*ninv%MOD;
    }
}
```

### FWT

$n$ 需补成 $2$ 的幂

```c++
template<typename T>
void fwt(LL a[],int n,T f)
{
    for (int d=1;d<n;d*=2)
        for (int i=0,t=d*2;i<n;i+=t)
            for (int j=0;j<d;j++)
                f(a[i+j],a[i+j+d]);
}

void AND(LL& a,LL& b){a+=b;}
void OR(LL& a,LL& b){b+=a;}
void XOR(LL& a,LL& b)
{
    LL x=a,y=b;
    a=(x+y)%MOD;
    b=(x-y+MOD)%MOD;
}
void rAND(LL& a,LL& b){a-=b;}
void rOR(LL& a,LL& b){b-=a;}
void rXOR(LL& a,LL& b)
{
    static LL INV2=(MOD+1)/2;
    LL x=a,y=b;
    a=(x+y)*INV2%MOD;
    b = (x-y+MOD)*INV2%MOD;
}
```

### 拉格朗日插值法

给定 $k+1$ 个取值点 $(x_0,y_0),\cdots ,(x_k,y_k)$

拉格朗日插值多项式 $L(x)=\sum _{j=0}^{k}y_jl_j(x)$

其中 $l_j(x)=\prod _{i=0,i\neq j}^{k} \frac{x-x_i}{x_j-x_i}$

## 数论

### MiLLer-Rabin

$O(log(n))$判素数

int 范围内只需检查 2, 7, 61
long long 范围 2, 325, 9375, 28178, 450775, 9780504, 1795265022
3E15内 2, 2570940, 880937, 610386380, 4130785767
4E13内 2, 2570940, 211991001, 3749873356

```cpp
const LL m=7, aa[m]={2, 3, 5, 7, 11, 13, 17};
LL n, p;

LL fmul(LL a, LL b, LL p){  //将b分解为二进制，返回a*b%p
    LL ans=0;
    for (; b; b>>=1, a+=a, a%=p)
        if (b&1) ans+=a, ans%=p;
    return ans;
}

LL fpow(LL a, LL x, LL p){
    LL ans=1, base=a;
    for (; x; x>>=1, base=fmul(base, base, p))
        if (x&1) ans=fmul(ans, base, p);
    return ans;
}

bool MR(LL a, LL x, LL p){
    LL t=fpow(a, x, p);
    if (t!=1&&t!=p-1) return false;
    if (t==1&&x&1||t==p-1) return true;
    return MR(a, x>>1, p);
}

bool isPrime(LL p){
    if (p < 2) return false;
    if (p == 2) return true;
    if (p&1==0) return false;
    for (LL i=0; i<m; ++i){
        if (p==aa[i]) return true;
        if (fpow(aa[i], p-1, p)!=1) return false;
        if (!MR(aa[i], (p-1)>>1, p)) return false;
    }
    return true;
}
```

### 莫比乌斯函数

线性筛，时间复杂度$O(n)$

```c++
const int MAXN=50000;
bool check[MAXN+10];
int prime[MAXN+10],mu[MAXN+10];

void Moblus()
{
    memset(check,0,sizeof(check));
    mu[1]=1;
    int tot=0;
    for (int i=2;i<=MAXN;i++)
    {
        if (!check[i]) prime[tot++]=i,mu[i]=-1;
        for (int j=0;j<tot;j++)
        {
            if (i*prime[j]>MAXN) break;
            check[i*prime[j]]=true;
            if (i%prime[j]==0){mu[i*prime[j]]=0;break;}
            else mu[i*prime[j]]=-mu[i];
        }
    }
}
```

### 类欧

返回 $\frac{x}{y}$ 满足 $\frac{p1}{q1}<\frac{x}{y}<\frac{p2}{q2}$ ，且 $x,y$ 是最小的

```c++
void solve(LL p1,LL q1,LL p2,LL q2,LL &x,LL &y)
{
  	LL l=p1/q1+1;
  	if (l*q2<p2){x=l; y=1;return;}
  	if (p1==0){x=1; y=q2/p2+1;return;}
  	if (p1<=q1 && p2<=q2){solve(q2,p2,q1,p1,y,x);return;}
  	ll t=p1/q1;
  	solve(p1-q1*t,q1,p2-q2*t,q2,x,y);
  	x+=y*t;
}
```

## 线性代数

### 高斯消元法

#### 浮点数版本

```cpp
namespace Guass {
typedef double T_Gauss;
const double EPS = 1e-6;

bool vis[MAXN];

int solve(T_Gauss a[][MAXN], bool l[], double ans[], const int &n);

inline int solve(T_Gauss a[][MAXN], bool l[], T_Gauss ans[], const int &n, const int &m) {
    // return 0 if one solution, > 0 if multi-solution and -1 if no solution

    int res = 0, r = 0;
    memset(l, 0, sizeof(bool)*n);
    memset(vis, 0, sizeof(bool)*n);
    for (int i=0; i<n; ++i) {
        for (int j=r; j<m; ++j)
            if (fabs(a[j][i]) > EPS) {
                for (int k=i; k<=n; ++k)
                    swap(a[j][k], a[r][k]);
                break;
            }
        if (fabs(a[r][i]) < EPS) {
            ++res;
            continue;
        }
        for (int j=0; j<m; ++j)
            if (j != r && fabs(a[j][i]) > EPS) {
                T_Gauss tmp = a[j][i] / a[r][i];
                for (int k=i; k<=n; ++k)
                    a[j][k] -= tmp*a[r][k];
            }
        l[i] = true; ++r;
    }
    // solution is not unique
    for (int i=0; i<n; ++i)
        if (l[i])
            for (int j=0; j<m; ++j)
                if (fabs(a[j][i]) > EPS) {
                    T_Gauss tans = a[j][n] / a[j][i];
                    if (!vis[i]) {
                        vis[i] = 1;
                    } else {
                        if (dcmp(ans[i] - tans))
                            return -1;
                    }
                    ans[i] = tans;
                }
    // equation is iLLegal
    for (int i=0; i<m; ++i) {
        bool zero = true;
        for (int j=0; j<n; ++j) {
            if (fabs(a[i][j]) > EPS) {
                zero = false;
                break;
            }
        }
        if (zero && fabs(a[i][n]) > EPS)
            return -1;
    }
    
                    
    return res;
}
}
```

#### 整数版本

注意数据范围，一般在系数很小的时候使用
+ 输入
  1. equ, var 分别表示方程数和变量数
  2. a[][]表示系数矩阵
+ 输出
  1. free_x[]表示是否是自由元
  2. x[]为解
  3. 返回-2为有浮点数解，-1无解，0唯一解，1多解

```cpp
namespace Gauss {
    typedef long long T_Gauss;
    T_Gauss a[MAXN][MAXN];
    T_Gauss x[MAXN];
    bool free_x[MAXN];

    inline void debug(int equ, int var) {
        for (int i=0; i<equ; ++i) {
            for (int j=0; j<=var; ++j) {
                printf("%10LLd ", a[i][j]);
            }
            putchar('\n');
        }
    }

    inline T_Gauss gcd(T_Gauss a, T_Gauss b) {
        T_Gauss t;
        while (b) {
            t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
    inline T_Gauss lcm(T_Gauss a, T_Gauss b) {
        return a / gcd(a, b) * b;
    }

    int solve(int equ, int var) {
        int i, j, k;
        T_Gauss max_r;
        int col;
        T_Gauss ta, tb;
        T_Gauss LCM;
        T_Gauss temp;
        int free_x_num;
        int free_index;

        memset(x, 0, sizeof(T_Gauss)*(var+1));
        memset(free_x, 0, sizeof(bool)*(var+1));

        // triangle matrix
        col = 0;
        for (k=0; k<equ && col<var; ++k, ++col) {
            max_r = k;
            for (i=k+1; i<equ; ++i) {
                if (abs(a[i][col]) > abs(a[max_r][col])) max_r = i;
            }
            if (max_r != k) {
                // swap with row k
                for (j=k; j<var+1; ++j)
                    swap(a[k][j], a[max_r][j]);
            }
            if (a[k][col] == 0) {
                // aLL zeors below row k
                k--;
                continue;
            }
            for (i=k+1; i<equ; ++i) {
                // rows to be elimenate
                if (a[i][col] != 0) {
                    LCM = lcm(abs(a[i][col]), abs(a[k][col]));
                    ta = LCM / abs(a[i][col]);
                    tb = LCM / abs(a[k][col]);
                    if (a[i][col] * a[k][col] < 0) tb = -tb; // add instead of minus
                    for ( j=col; j<var+1; ++j) {
                        a[i][j] = a[i][j] * ta - a[k][j] * tb;
                    }
                }
            }
        }

        // debug(equ, var);
        // return 0;

        // no solution: when (0,0,0,...,0,a) a!=0
        for (i=k; i<equ; ++i) {
            if (a[i][col] != 0) return -1;
        }

        // multi solution: when (0,...0) appears
        if (k < var) {
            for (i=k-1; i>=0; --i) {
                free_x_num = 0;
                for (j=0; j<var; ++j) {
                    if (a[i][j] != 0 && free_x[j]) {
                        free_x_num++;
                        free_index = j;
                    }
                }
                if (free_x_num > 1) continue;
                temp = a[i][var];
                for (j=0; j<var; ++j) {
                    if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];
                }
                x[free_index] = temp / a[i][free_index];
                free_x[free_index] = 0;
            }
            return var - k;
        }

        // one solution: strict triangle matrix
        for (i=var-1; i>=0; --i) {
            temp = a[i][var];
            for (j=i+1; j<var; ++j) {
                if (a[i][j] != 0) temp -= a[i][j] * x[j];
            }
            if (temp % a[i][i] != 0)
                return -2; //float number solution
            x[i] = temp / a[i][i];
        }
        return 0;
    }

}
```

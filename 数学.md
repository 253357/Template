# 数学

## 数论


### Miller-Rabin

$O(log(n))$判素数

```cpp
const LL m=7, aa[m]={2, 3, 5, 7, 11, 13, 17};
LL n, p;

LL fmul(LL a, LL b, LL p){  //将b分解为二进制，返回a*b%p
    LL ans=0;
    for (; b; b>>=1, a+=a, a%=p)
        if (b&1) ans+=a, ans%=p;
    return ans;
}

LL fpow(LL a, LL x, LL p){
    LL ans=1, base=a;
    for (; x; x>>=1, base=fmul(base, base, p))
        if (x&1) ans=fmul(ans, base, p);
    return ans;
}

bool MR(LL a, LL x, LL p){
    LL t=fpow(a, x, p);
    if (t!=1&&t!=p-1) return false;
    if (t==1&&x&1||t==p-1) return true;
    return MR(a, x>>1, p);
}

bool isPrime(LL p){
    if (p < 2) return false;
    if (p == 2) return true;
    if (p&1==0) return false;
    for (LL i=0; i<m; ++i){
        if (p==aa[i]) return true;
        if (fpow(aa[i], p-1, p)!=1) return false;
        if (!MR(aa[i], (p-1)>>1, p)) return false;
    }
    return true;
}

```

### 莫比乌斯函数

线性筛，时间复杂度$O(n)$

```c++
const int MAXN=50000;
bool check[MAXN+10];
int prime[MAXN+10],mu[MAXN+10];

void Moblus()
{
    memset(check,0,sizeof(check));
    mu[1]=1;
    int tot=0;
    for (int i=2;i<=MAXN;i++)
    {
        if (!check[i]) prime[tot++]=i,mu[i]=-1;
        for (int j=0;j<tot;j++)
        {
            if (i*prime[j]>MAXN) break;
            check[i*prime[j]]=true;
            if (i%prime[j]==0){mu[i*prime[j]]=0;break;}
            else mu[i*prime[j]]=-mu[i];
        }
    }
}
```

## 线性代数

### 高斯消元法

#### 浮点数版本

```cpp
namespace Guass {
typedef double T_Gauss;
const double EPS = 1e-6;

bool vis[MAXN];

int solve(T_Gauss a[][MAXN], bool l[], double ans[], const int &n);

inline int solve(T_Gauss a[][MAXN], bool l[], T_Gauss ans[], const int &n, const int &m) {
    // return 0 if one solution, > 0 if multi-solution and -1 if no solution

    int res = 0, r = 0;
    memset(l, 0, sizeof(bool)*n);
    memset(vis, 0, sizeof(bool)*n);
    for (int i=0; i<n; ++i) {
        for (int j=r; j<m; ++j)
            if (fabs(a[j][i]) > EPS) {
                for (int k=i; k<=n; ++k)
                    swap(a[j][k], a[r][k]);
                break;
            }
        if (fabs(a[r][i]) < EPS) {
            ++res;
            continue;
        }
        for (int j=0; j<m; ++j)
            if (j != r && fabs(a[j][i]) > EPS) {
                T_Gauss tmp = a[j][i] / a[r][i];
                for (int k=i; k<=n; ++k)
                    a[j][k] -= tmp*a[r][k];
            }
        l[i] = true; ++r;
    }
    // solution is not unique
    for (int i=0; i<n; ++i)
        if (l[i])
            for (int j=0; j<m; ++j)
                if (fabs(a[j][i]) > EPS) {
                    T_Gauss tans = a[j][n] / a[j][i];
                    if (!vis[i]) {
                        vis[i] = 1;
                    } else {
                        if (dcmp(ans[i] - tans))
                            return -1;
                    }
                    ans[i] = tans;
                }
    // equation is illegal
    for (int i=0; i<m; ++i) {
        bool zero = true;
        for (int j=0; j<n; ++j) {
            if (fabs(a[i][j]) > EPS) {
                zero = false;
                break;
            }
        }
        if (zero && fabs(a[i][n]) > EPS)
            return -1;
    }
    
                    
    return res;
}
}
```

#### 整数版本

注意数据范围，一般在系数很小的时候使用
+ 输入
  1. equ, var 分别表示方程数和变量数
  2. a[][]表示系数矩阵
+ 输出
  1. free_x[]表示是否是自由元
  2. x[]为解
  3. 返回-2为有浮点数解，-1无解，0唯一解，1多解

```cpp
namespace Gauss {
    typedef long long T_Gauss;
    T_Gauss a[MAXN][MAXN];
    T_Gauss x[MAXN];
    bool free_x[MAXN];

    inline void debug(int equ, int var) {
        for (int i=0; i<equ; ++i) {
            for (int j=0; j<=var; ++j) {
                printf("%10lld ", a[i][j]);
            }
            putchar('\n');
        }
    }

    inline T_Gauss gcd(T_Gauss a, T_Gauss b) {
        T_Gauss t;
        while (b) {
            t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
    inline T_Gauss lcm(T_Gauss a, T_Gauss b) {
        return a / gcd(a, b) * b;
    }

    int solve(int equ, int var) {
        int i, j, k;
        T_Gauss max_r;
        int col;
        T_Gauss ta, tb;
        T_Gauss LCM;
        T_Gauss temp;
        int free_x_num;
        int free_index;

        memset(x, 0, sizeof(T_Gauss)*(var+1));
        memset(free_x, 0, sizeof(bool)*(var+1));

        // triangle matrix
        col = 0;
        for (k=0; k<equ && col<var; ++k, ++col) {
            max_r = k;
            for (i=k+1; i<equ; ++i) {
                if (abs(a[i][col]) > abs(a[max_r][col])) max_r = i;
            }
            if (max_r != k) {
                // swap with row k
                for (j=k; j<var+1; ++j)
                    swap(a[k][j], a[max_r][j]);
            }
            if (a[k][col] == 0) {
                // all zeors below row k
                k--;
                continue;
            }
            for (i=k+1; i<equ; ++i) {
                // rows to be elimenate
                if (a[i][col] != 0) {
                    LCM = lcm(abs(a[i][col]), abs(a[k][col]));
                    ta = LCM / abs(a[i][col]);
                    tb = LCM / abs(a[k][col]);
                    if (a[i][col] * a[k][col] < 0) tb = -tb; // add instead of minus
                    for ( j=col; j<var+1; ++j) {
                        a[i][j] = a[i][j] * ta - a[k][j] * tb;
                    }
                }
            }
        }

        // debug(equ, var);
        // return 0;

        // no solution: when (0,0,0,...,0,a) a!=0
        for (i=k; i<equ; ++i) {
            if (a[i][col] != 0) return -1;
        }

        // multi solution: when (0,...0) appears
        if (k < var) {
            for (i=k-1; i>=0; --i) {
                free_x_num = 0;
                for (j=0; j<var; ++j) {
                    if (a[i][j] != 0 && free_x[j]) {
                        free_x_num++;
                        free_index = j;
                    }
                }
                if (free_x_num > 1) continue;
                temp = a[i][var];
                for (j=0; j<var; ++j) {
                    if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];
                }
                x[free_index] = temp / a[i][free_index];
                free_x[free_index] = 0;
            }
            return var - k;
        }

        // one solution: strict triangle matrix
        for (i=var-1; i>=0; --i) {
            temp = a[i][var];
            for (j=i+1; j<var; ++j) {
                if (a[i][j] != 0) temp -= a[i][j] * x[j];
            }
            if (temp % a[i][i] != 0)
                return -2; //float number solution
            x[i] = temp / a[i][i];
        }
        return 0;
    }

}
```

```
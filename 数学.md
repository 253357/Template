# 数学

## 数论

### 莫比乌斯函数

线性筛，时间复杂度$O(n)$

```c++
const int MAXN=50000;
bool check[MAXN+10];
int prime[MAXN+10],mu[MAXN+10];

void Moblus()
{
    memset(check,0,sizeof(check));
    mu[1]=1;
    int tot=0;
    for (int i=2;i<=MAXN;i++)
    {
        if (!check[i]) prime[tot++]=i,mu[i]=-1;
        for (int j=0;j<tot;j++)
        {
            if (i*prime[j]>MAXN) break;
            check[i*prime[j]]=true;
            if (i%prime[j]==0){mu[i*prime[j]]=0;break;}
            else mu[i*prime[j]]=-mu[i];
        }
    }
}
```

## 杂项

### 高斯消元法

#### 浮点数版本

```cpp
namespace Guass {
typedef double T_Gauss;
const double EPS = 1e-6;

bool vis[MAXN];

int solve(T_Gauss a[][MAXN], bool l[], double ans[], const int &n);

inline int solve(T_Gauss a[][MAXN], bool l[], T_Gauss ans[], const int &n, const int &m) {
    // return 0 if one solution, > 0 if multi-solution and -1 if no solution

    int res = 0, r = 0;
    memset(l, 0, sizeof(bool)*n);
    memset(vis, 0, sizeof(bool)*n);
    for (int i=0; i<n; ++i) {
        for (int j=r; j<m; ++j)
            if (fabs(a[j][i]) > EPS) {
                for (int k=i; k<=n; ++k)
                    swap(a[j][k], a[r][k]);
                break;
            }
        if (fabs(a[r][i]) < EPS) {
            ++res;
            continue;
        }
        for (int j=0; j<m; ++j)
            if (j != r && fabs(a[j][i]) > EPS) {
                T_Gauss tmp = a[j][i] / a[r][i];
                for (int k=i; k<=n; ++k)
                    a[j][k] -= tmp*a[r][k];
            }
        l[i] = true; ++r;
    }
    // solution is not unique
    for (int i=0; i<n; ++i)
        if (l[i])
            for (int j=0; j<m; ++j)
                if (fabs(a[j][i]) > EPS) {
                    T_Gauss tans = a[j][n] / a[j][i];
                    if (!vis[i]) {
                        vis[i] = 1;
                    } else {
                        if (dcmp(ans[i] - tans))
                            return -1;
                    }
                    ans[i] = tans;
                }
    // equation is illegal
    for (int i=0; i<m; ++i) {
        bool zero = true;
        for (int j=0; j<n; ++j) {
            if (fabs(a[i][j]) > EPS) {
                zero = false;
                break;
            }
        }
        if (zero && fabs(a[i][n]) > EPS)
            return -1;
    }
    
                    
    return res;
}
}

```
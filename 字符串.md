# 字符串

## Trie

<b>Trie注意开足数组大小！</b>

* $ch[i][j]$ 表示Trie中结点 $i$ 的孩子 $j$ 的编号
* $val[i]>0$ 表示结点 $i$ 为一个单词的结尾结点

```c++
struct Trie
{
    int ch[400010][26],val[400010];
    int sz;
    void init()
    {
        sz=1;
        memset(ch[0],0,sizeof(ch[0]));
    }
    int idx(char c){return c-'a';}
    void insert(char *s,int v)
    {
        int u=0,n=strlen(s);
        for (int i=0;i<n;i++)
        {
            int c=idx(s[i]);
            if (!ch[u][c])
            {
                memset(ch[sz],0,sizeof(ch[sz]));
                val[sz]=0;
                ch[u][c]=sz++;
            }
            u=ch[u][c];
        }              
        val[u]=v;
    }
}tree;
```

### 可持久化Trie

* insert(s,n,x) 插入的字符串为$s_0,\cdots ,s_{n-1}$，长度为$n$，当前是$x$位（其中$x$和$u$是树上对应的位置）
* $val[x]$表示当前节点上经过的单词个数

```c++
struct Tries
{
    int ch[20000010][2],val[20000010];
    int sz,h[20000010];
    void init()
    {
        sz=1;
        memset(h,-1,sizeof(h));h[0]=0;
        memset(val,0,sizeof(val));
        memset(ch[0],0,sizeof(ch[0]));
    }
    int idx(char c){return c-'0';}
    void insert(char *s,int n,int x)//No.x trie   u/x
    {
        int u=h[x-1];h[x]=sz++;x=h[x];
        for (int i=0;i<n;i++)
        {
            int c=idx(s[i]);
            for (int j=0;j<=1;j++)
                ch[x][j]=ch[u][j];
            memset(ch[sz],0,sizeof(ch[sz]));
            ch[x][c]=sz++;
            u=ch[u][c];
            x=ch[x][c];
            val[x]=val[u]+1;
        }
    }
}tree;
```

## KMP

主串$s$，长度为$n$

模式串$t$，长度为$m$

```c++
void Pre_KMP()
{
    for (int i=0;i<=m;i++)
        Next[i]=0;
    int j=0,k=-1;
    Next[0]=-1;
    while(j<m)
    {
        if (k==-1||t[j]==t[k]) Next[++j]=++k;
        else k=Next[k];
    }
}

int KMP(int s[],int t[])
{
    int i=0,j=0;
    while(i<n&&j<m)
    {
        if (j==-1||s[i]==t[j]) i++,j++;
        else j=Next[j];
    }
    if (j==m) return i-m;
    else return -1;
}
```

### 常见应用

* 长度为$len$字符串的最短循环节长度为$len-Next[len]$


# 字符串

## Trie

<b>Trie注意开足数组大小！</b>

* $ch[i][j]$ 表示Trie中结点 $i$ 的孩子 $j$ 的编号
* $val[i]>0$ 表示结点 $i$ 为一个单词的结尾结点

```c++
struct Trie
{
    int ch[400010][26],val[400010];
    int sz;
    void init()
    {
        sz=1;
        memset(ch[0],0,sizeof(ch[0]));
    }
    int idx(char c){return c-'a';}
    void insert(char *s,int v)
    {
        int u=0,n=strlen(s);
        for (int i=0;i<n;i++)
        {
            int c=idx(s[i]);
            if (!ch[u][c])
            {
                memset(ch[sz],0,sizeof(ch[sz]));
                val[sz]=0;
                ch[u][c]=sz++;
            }
            u=ch[u][c];
        }              
        val[u]=v;
    }
}tree;
```

### 可持久化Trie

* insert(s,n,x) 插入的字符串为$s_0,\cdots ,s_{n-1}$，长度为$n$，当前是$x$位（其中$x$和$u$是树上对应的位置）
* $val[x]$表示当前节点上经过的单词个数

```c++
struct Tries
{
    int ch[20000010][2],val[20000010];
    int sz,h[20000010];
    void init()
    {
        sz=1;
        memset(h,-1,sizeof(h));h[0]=0;
        memset(val,0,sizeof(val));
        memset(ch[0],0,sizeof(ch[0]));
    }
    int idx(char c){return c-'0';}
    void insert(char *s,int n,int x)//No.x trie   u/x
    {
        int u=h[x-1];h[x]=sz++;x=h[x];
        for (int i=0;i<n;i++)
        {
            int c=idx(s[i]);
            for (int j=0;j<=1;j++)
                ch[x][j]=ch[u][j];
            memset(ch[sz],0,sizeof(ch[sz]));
            ch[x][c]=sz++;
            u=ch[u][c];
            x=ch[x][c];
            val[x]=val[u]+1;
        }
    }
}tree;
```

## KMP

主串$s$，长度为$n$

模式串$t$，长度为$m$

```c++
struct kmp
{
    int s[1000010],t[1000010],Next[1000010];
    void Pre_KMP()
    {
        for (int i=0;i<=m;i++)
            Next[i]=0;
        int j=0,k=-1;
        Next[0]=-1;
        while(j<m)
        {
            if (k==-1||t[j]==t[k]) Next[++j]=++k;
            else k=Next[k];
        }
    }
    int KMP()
    {
        int i=0,j=0;
        while(i<n&&j<m)
        {
            if (j==-1||s[i]==t[j]) i++,j++;
            else j=Next[j];
        }
        if (j==m) return i-m;
        else return -1;
    }
}K;
```

### 常见应用

以下均指开始下标为$0$的字符串

* 长度为$len$字符串的最短循环节长度为$len-Next[len]$
* $Next[i]$表示$i-1$为结尾的字符串的最长公共前后缀（不算本身）
* 前缀$i$的最长循环节长度为$i-f[i]$(不算本身)

```c++
for (int i=1;i<=K.m;i++)
    if (K.Next[i]==0) f[i]=i;
    else f[i]=f[K.Next[i]];
```

### 扩展KMP

* $next[i]$表示模式串$T[0\cdots (m-1)]$和$T[i\cdots (m-1)]$的最长公共前缀。
* $extand[i]$表示模式串$T[0\cdots (m-1)]$和主串$S[i\cdots (m-1)]$的最长公共前缀。

```c++
struct exkmp
{
    int next[1000010],extand[1000010];
    char S[1000010],T[1000010];
    void GetNext()
    {
        int len=strlen(T),a=0;
        next[0]=len;
        while(a<len-1&&T[a]==T[a+1]) a++;
        next[1]=a;a=1;
        for(int k=2;k<len;k++)
        {
            int p=a+next[a]-1,L=next[k-a];
            if((k-1)+L>=p)
            {
                int j=(p-k+1)>0?(p-k+1):0;
                while(k+j<len&&T[k+j]==T[j]) j++;
                next[k]=j;
                a=k;
            }
            else next[k]=L; 
        }
    }
    void GetExtand()
    {
        int slen=strlen(S),tlen=strlen(T),a=0; 
        int MinLen=slen<tlen?slen:tlen;
        while(a<MinLen&&S[a]==T[a]) a++;
        extand[0]=a;a=0;
        for(int k=1;k<slen;k++)
        {
            int p=a+extand[a]-1,L=next[k-a];
            if((k-1)+L>=p)
            {
                int j=(p-k+1)>0?(p-k+1):0;
                while(k+j<slen&&j<tlen&&S[k+j]==T[j]) j++;
                extand[k]=j;
                a=k; 
            }
            else extand[k]=L; 
        }
    }
}K;
```

## AC 自动机

### 强制在线自动机

* $1\;s$ 插入模式串 $s$
* $2\;s$ 删除模式串 $s$
* $3\;t$ 存在的模式串与主串 $t$ 匹配，单个模式串的多个匹配均算

询问次数在 $3\cdot 10^5$ 附近

```c++
#define N 310000
int m,cnt;
char s[N];
struct acauto
{
    int ch[N][27],fail[N],en[N],en1[N],cnt;
    int num[31],root[31],top;
    queue<int>que;
    void acmatch(int x)
    {
        que.push(x);
        while(!que.empty())
        {
            int tmp=que.front();que.pop();
            for(int i=1;i<=26;i++)
                if(ch[tmp][i])
                {
                    int t=fail[tmp],t1=ch[tmp][i];
                    while(t&&!ch[t][i])t=fail[t];
                    fail[t1]=t?ch[t][i]:x;
                    que.push(t1);
                    en1[t1]=en1[fail[t1]]+en[t1];
                }
        }
    }
    int merge(int x,int y)
    {
        if(!x||!y)return x+y;
        en[x]=en[x]|en[y];
        for(int i=1;i<=26;i++)
            ch[x][i]=merge(ch[x][i],ch[y][i]);
        return x;
    }
    void insert()
    {
        scanf("%s",s+1);
        int len=strlen(s+1);
        root[++top]=++cnt;
        int now=root[top];
        for(int i=1,t;i<=len;i++)
        {
            if(!ch[now][t=s[i]-'a'+1])
                ch[now][t]=++cnt;
            now=ch[now][t];
        }
        en[now]=1;num[top]=1;
        acmatch(root[top]);
        while(top&&num[top]==num[top-1])
        {
            merge(root[top-1],root[top]);
            acmatch(root[top-1]);
            num[top-1]+=num[top];top--;
        }
    }
    int query(int len)
    {
        int ret=0;
        for(int i=1;i<=top;i++)
        {
            for(int now=root[i],j=1,t;j<=len;j++)
            {
                t=s[j]-'a'+1;
                while(now&&!ch[now][t])
                    now=fail[now];
                now=now?ch[now][t]:root[i];
                ret+=en1[now];
            }
        }
        return ret;
    }
}ac1,ac2;
int main()
{
    scanf("%d",&m);
    int x;
    while(m--)
    {
        scanf("%d",&x);
        if(x==1) ac1.insert();
        else if(x==2) ac2.insert();
        else 
        {
            scanf("%s",s+1);
            int len=strlen(s+1);
            printf("%d\n",ac1.query(len)-ac2.query(len));
        }
    }
    return 0;
}
```
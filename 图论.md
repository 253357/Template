# 图论

## 网络流

### 最大流

* 边的原流量 - 残余网络流量 = 这条边的实际流量
* 残余网络有元素个数不少于 $2$ 的环，则最大流方案不唯一
* 判断边 (x,y) 是否为割边 !edge[].cp&&!DC.BFS(x,y)
* 删除边 (x,y) 退流 DC.go(x,s),DC.go(t,y),edge[].cp=0,edge[+1].cp=0

```c++
#define INF 0x3fffffff
struct E
{
    int to,cp;
    E(int to,int cp):to(to),cp(cp){}
};
struct Dinic
{
    static const int M=1E5*5;
    int m;
    vector<E> edges;
    vector<int> G[M];
    int d[M];
    int cur[M];
    void init(int n)
    {
        for (int i=0;i<=n;i++) G[i].clear();
        edges.clear();m=0;
    }
    void addedge(int u,int v,int cap)
    {
        edges.push_back(E(v,cap));
        edges.push_back(E(u,0));
        G[u].push_back(m++);
        G[v].push_back(m++);
    }
    bool BFS(int s,int t)
    {
        memset(d,0,sizeof d);
        queue<int> Q;
        Q.push(s);d[s]=1;
        while (!Q.empty())
        {
            int x=Q.front();Q.pop();
            for (int& i: G[x])
            {
                E &e=edges[i];
                if (!d[e.to]&&e.cp>0)
                {
                    d[e.to]=d[x]+1;
                    Q.push(e.to);
                }
            }
        }
        return d[t];
    }
    int DFS(int u,int cp,int s,int t)
    {
        if (u==t||!cp) return cp;
        int tmp=cp,f;
        for (int& i=cur[u];i<G[u].size();i++)
        {
            E& e=edges[G[u][i]];
            if (d[u]+1==d[e.to])
            {
                f=DFS(e.to,min(cp,e.cp),s,t);
                e.cp-=f;
                edges[G[u][i]^1].cp+=f;
                cp-=f;
                if (!cp) break;
            }
        }
        return tmp-cp;
    }
    int go(int s,int t)
    {
        int flow=0;
        while (BFS(s,t))
        {
            memset(cur,0,sizeof cur);
            flow+=DFS(s,INF,s,t);
        }
        return flow;
    }
}DC;
int main()
{
    DC.init(n*m+2);
    cout<<DC.go(S,T)<<endl;
}
```

## 最小树形图

给出带权有向图，求节点$1$到所有节点单向联通的最小代价。

```c++
const int N=3e5+10;
const LL INF=1e15;
typedef pair<LL,int> P;

struct MTD
{
    set<P> G[N];
    LL shift[N];
    bool vis[N];
    int n,m,stk[N],top,fa[N];
    int Fa(int x){return fa[x]==x?x:fa[x]=Fa(fa[x]);}
    void init(int _n,int _m)
    {
        n=_n;m=_m;
        for (int i=0;i<=n;i++) fa[i]=i;
    }
    LL solve()
    {
        LL ans=0;
        for (int i=2;i<=n;i++)
        {
            int u=i;top=0;
            while(Fa(u)!=Fa(1))
            {
                vis[u]=true;stk[top++]=u;
                auto it=G[u].begin();
                while(it!=G[u].end())
                {
                    int v=it->second;
                    if (Fa(v)==Fa(u)) it=G[u].erase(it);
                    else break;
                }
                if(it==G[u].end())return -INF;
                LL lb=it->first;
                int v=it->second;
                G[u].erase(it);
                v=Fa(v);
                ans+=lb+shift[u];
                shift[u]=-lb;
                if(vis[v] && Fa(v)!=Fa(1))
                {
                    int x=v;
                    while(stk[top-1]!=v)
                    {
                        int y=stk[--top];
                        fa[Fa(y)]=Fa(x);
                        if(G[x].size()<G[y].size()) G[x].swap(G[y]),swap(shift[x],shift[y]);
                        for(auto pr: G[y])
                            G[x].insert(P(pr.first+shift[y]-shift[x],pr.second));
                        G[y].clear();
                    }
                }
                u=v;
            }
            while(top--) fa[Fa(stk[top])]=1;
        }
        for (int i=2;i<=n;i++)
            if(Fa(i)!=Fa(1)) return -INF;
        return ans;
    }
}tree;

int n,m;

int main()
{
    scanf("%d%d",&n,&m);
    tree.init(n,m);
    int u,v,w;
    for (int i=0;i<m;i++)
        scanf("%d%d%d",&u,&v,&w),tree.G[v].insert(P(w,u));
    LL ans=tree.solve();
    if (ans==-INF) puts("NO");else printf("%lld\n",ans);
}
```

## 支配树

* S是起点。
* dt 存下了支配树的信息，如果$x$是$y$的祖先，那么$x$是起点到$y$的必经点。
* $idom[x]$ 是节点$x$的最近必经点

```c++
vector<int> G[N],rG[N];
vector<int> dt[N];

struct tl
{
    int fa[N],idx[N],clk,ridx[N];
    int c[N],best[N],semi[N],idom[N];
    void init(int n)
    {
        clk=0;
        fill(c,c+n+1,-1);
        for (int i=1;i<=n;i++) dt[i].clear();
        for (int i=1;i<=n;i++) semi[i]=best[i]=i;
        fill(idx,idx+n+1,0);
        for (int u=1;u<=n;u++)
            for (int v:G[u])
                rG[v].push_back(u);
    }
    void dfs(int u)
    {
        idx[u]=++clk;ridx[clk]=u;
        for (int& v:G[u]) if (!idx[v]){fa[v]=u;dfs(v);}
    }
    int fix(int x)
    {
        if (c[x]==-1) return x;
        int &f=c[x],rt=fix(f);
        if (idx[semi[best[x]]]>idx[semi[best[f]]]) best[x]=best[f];
        return f=rt;
    }
    void go(int rt)
    {
        dfs(rt);
        for (int i=clk;i>1;i--)
        {
            int x=ridx[i],mn=clk+1;
            for (int& u:rG[x])
            {
                if (!idx[u]) continue;
                fix(u);mn=min(mn,idx[semi[best[u]]]);
            }
            c[x]=fa[x];
            dt[semi[x]=ridx[mn]].push_back(x);
            x=ridx[i-1];
            for (int& u: dt[x])
            {
                fix(u);
                if (semi[best[u]]!=x) idom[u]=best[u];
                else idom[u]=x;
            }
            dt[x].clear();
        }
        for (int i=2;i<=clk;i++)
        {
            int u=ridx[i];
            if (idom[u]!=semi[u]) idom[u]=idom[idom[u]];
            dt[idom[u]].push_back(u);
        }
    }
}tree;
int main()
{
    int x,p,q;
    scanf("%d%d%d",&n,&m,&x);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&p,&q);
        G[p].push_back(q);
    }
    tree.init(n);
    tree.go(x);
}
```
# 图论

## 网络流

### 最大流

* 边的原流量 - 残余网络流量 = 这条边的实际流量
* 残余网络有元素个数不少于 $2$ 的环，则最大流方案不唯一
* 判断边 (x,y) 是否为割边 !edge[].cp&&!DC.BFS(x,y)
* 删除边 (x,y) 退流 DC.go(x,s),DC.go(t,y),edge[].cp=0,edge[+1].cp=0

```c++
#define INF 0x3fffffff
struct E
{
    int to,cp;
    E(int to,int cp):to(to),cp(cp){}
};
struct Dinic
{
    static const int M=1E5*5;
    int m;
    vector<E> edges;
    vector<int> G[M];
    int d[M];
    int cur[M];
    void init(int n)
    {
        for (int i=0;i<=n;i++) G[i].clear();
        edges.clear();m=0;
    }
    void addedge(int u,int v,int cap)
    {
        edges.push_back(E(v,cap));
        edges.push_back(E(u,0));
        G[u].push_back(m++);
        G[v].push_back(m++);
    }
    bool BFS(int s,int t)
    {
        memset(d,0,sizeof d);
        queue<int> Q;
        Q.push(s);d[s]=1;
        while (!Q.empty())
        {
            int x=Q.front();Q.pop();
            for (int& i: G[x])
            {
                E &e=edges[i];
                if (!d[e.to]&&e.cp>0)
                {
                    d[e.to]=d[x]+1;
                    Q.push(e.to);
                }
            }
        }
        return d[t];
    }
    int DFS(int u,int cp,int s,int t)
    {
        if (u==t||!cp) return cp;
        int tmp=cp,f;
        for (int& i=cur[u];i<G[u].size();i++)
        {
            E& e=edges[G[u][i]];
            if (d[u]+1==d[e.to])
            {
                f=DFS(e.to,min(cp,e.cp),s,t);
                e.cp-=f;
                edges[G[u][i]^1].cp+=f;
                cp-=f;
                if (!cp) break;
            }
        }
        return tmp-cp;
    }
    int go(int s,int t)
    {
        int flow=0;
        while (BFS(s,t))
        {
            memset(cur,0,sizeof cur);
            flow+=DFS(s,INF,s,t);
        }
        return flow;
    }
}DC;
int main()
{
    DC.init(n*m+2);
    cout<<DC.go(S,T)<<endl;
}
```

### 最小费用最大流

```c++
#define INF 0x3fffffff
struct E
{
    int from,to,cp,v;
    E(){}
    E(int f,int t,int cp,int v):from(f),to(t),cp(cp),v(v){}
};
struct MCMF
{
    int n,m,s,t;
    vector<E> edges;
    vector<int> G[maxn];
    bool inq[maxn];     //是否在队列
    int d[maxn];        //Bellman_ford单源最短路径
    int p[maxn];        //p[i]表从s到i的最小费用路径上的最后一条弧编号
    int a[maxn];        //a[i]表示从s到i的最小残量
    void init(int _n, int _s, int _t) {
        n = _n; s = _s; t = _t;
        for (int i=0;i<=n;i++) G[i].clear();
        edges.clear(); m = 0;
    }

    void addedge(int from, int to, int cap, int cost) {
        edges.push_back(E(from, to, cap, cost));
        edges.push_back(E(to, from, 0, -cost));
        G[from].push_back(m++);
        G[to].push_back(m++);
    }

    bool BellmanFord(int &flow, int &cost) {
        for (int i=0;i<=n;i++) d[i] = INF;
        memset(inq, 0, sizeof inq);
        d[s] = 0, a[s] = INF, inq[s] = true;
        queue<int> Q; Q.push(s);
        while (!Q.empty()) {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for (int& idx: G[u]) {
                E &e = edges[idx];
                if (e.cp && d[e.to] > d[u] + e.v) {
                    d[e.to] = d[u] + e.v;
                    p[e.to] = idx;
                    a[e.to] = min(a[u], e.cp);
                    if (!inq[e.to]) {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if (d[t] == INF) return false;
        flow += a[t];
        cost += a[t] * d[t];
        int u = t;
        while (u != s) {
            edges[p[u]].cp -= a[t];
            edges[p[u] ^ 1].cp += a[t];
            u = edges[p[u]].from;
        }
        return true;
    }

    int go(int &x) {
        int flow = 0, cost = 0;
        while (BellmanFord(flow, cost));
        x=flow;
        return cost;
    }
} MM;
int main()
{
    MM.init(n+n+2,n+n+1,n+n+2);
    int flow,ans;
    ans=MM.go(flow);
}
```

## 最小树形图

给出带权有向图，求节点$1$到所有节点单向联通的最小代价。

```c++
const int N=3e5+10;
const LL INF=1e15;
typedef pair<LL,int> P;

struct MTD
{
    set<P> G[N];
    LL shift[N];
    bool vis[N];
    int n,m,stk[N],top,fa[N];
    int Fa(int x){return fa[x]==x?x:fa[x]=Fa(fa[x]);}
    void init(int _n,int _m)
    {
        n=_n;m=_m;
        for (int i=0;i<=n;i++) fa[i]=i;
    }
    LL solve()
    {
        LL ans=0;
        for (int i=2;i<=n;i++)
        {
            int u=i;top=0;
            while(Fa(u)!=Fa(1))
            {
                vis[u]=true;stk[top++]=u;
                auto it=G[u].begin();
                while(it!=G[u].end())
                {
                    int v=it->second;
                    if (Fa(v)==Fa(u)) it=G[u].erase(it);
                    else break;
                }
                if(it==G[u].end())return -INF;
                LL lb=it->first;
                int v=it->second;
                G[u].erase(it);
                v=Fa(v);
                ans+=lb+shift[u];
                shift[u]=-lb;
                if(vis[v] && Fa(v)!=Fa(1))
                {
                    int x=v;
                    while(stk[top-1]!=v)
                    {
                        int y=stk[--top];
                        fa[Fa(y)]=Fa(x);
                        if(G[x].size()<G[y].size()) G[x].swap(G[y]),swap(shift[x],shift[y]);
                        for(auto pr: G[y])
                            G[x].insert(P(pr.first+shift[y]-shift[x],pr.second));
                        G[y].clear();
                    }
                }
                u=v;
            }
            while(top--) fa[Fa(stk[top])]=1;
        }
        for (int i=2;i<=n;i++)
            if(Fa(i)!=Fa(1)) return -INF;
        return ans;
    }
}tree;

int n,m;

int main()
{
    scanf("%d%d",&n,&m);
    tree.init(n,m);
    int u,v,w;
    for (int i=0;i<m;i++)
        scanf("%d%d%d",&u,&v,&w),tree.G[v].insert(P(w,u));
    LL ans=tree.solve();
    if (ans==-INF) puts("NO");else printf("%lld\n",ans);
}
```

## 支配树

* S是起点。
* dt 存下了支配树的信息，如果$x$是$y$的祖先，那么$x$是起点到$y$的必经点。
* $idom[x]$ 是节点$x$的最近必经点

```c++
vector<int> G[N],rG[N];
vector<int> dt[N];

struct tl
{
    int fa[N],idx[N],clk,ridx[N];
    int c[N],best[N],semi[N],idom[N];
    void init(int n)
    {
        clk=0;
        fill(c,c+n+1,-1);
        for (int i=1;i<=n;i++) dt[i].clear();
        for (int i=1;i<=n;i++) semi[i]=best[i]=i;
        fill(idx,idx+n+1,0);
        for (int u=1;u<=n;u++)
            for (int v:G[u])
                rG[v].push_back(u);
    }
    void dfs(int u)
    {
        idx[u]=++clk;ridx[clk]=u;
        for (int& v:G[u]) if (!idx[v]){fa[v]=u;dfs(v);}
    }
    int fix(int x)
    {
        if (c[x]==-1) return x;
        int &f=c[x],rt=fix(f);
        if (idx[semi[best[x]]]>idx[semi[best[f]]]) best[x]=best[f];
        return f=rt;
    }
    void go(int rt)
    {
        dfs(rt);
        for (int i=clk;i>1;i--)
        {
            int x=ridx[i],mn=clk+1;
            for (int& u:rG[x])
            {
                if (!idx[u]) continue;
                fix(u);mn=min(mn,idx[semi[best[u]]]);
            }
            c[x]=fa[x];
            dt[semi[x]=ridx[mn]].push_back(x);
            x=ridx[i-1];
            for (int& u: dt[x])
            {
                fix(u);
                if (semi[best[u]]!=x) idom[u]=best[u];
                else idom[u]=x;
            }
            dt[x].clear();
        }
        for (int i=2;i<=clk;i++)
        {
            int u=ridx[i];
            if (idom[u]!=semi[u]) idom[u]=idom[idom[u]];
            dt[idom[u]].push_back(u);
        }
    }
}tree;
int main()
{
    int x,p,q;
    scanf("%d%d%d",&n,&m,&x);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&p,&q);
        G[p].push_back(q);
    }
    tree.init(n);
    tree.go(x);
}
```

## 边双连通分量

+ 邻接表编写
+ 边从0开始标号，点从1开始
+ init()清空，go()搞好id[]，也就是缩点编号
+ POJ3177, ZOJ4097

```cpp
vector<int> u, v;
namespace EDCC {
vector<int> dfn, low, id;
vector<bool> insta;
stack<int> sta;

int edcc;
vector< vector< pair<int, int> > > G;
int clk;

void init(int n) {
    clk = 0;
    dfn.resize(n+1);
    fill(dfn.begin(), dfn.end(), 0);
    low.resize(n+1);
    fill(low.begin(), low.end(), 0);
    G.resize(n+1);
    FOR (i, 1, n+1)
        G[i].clear();
    id.resize(n+1);
    fill(id.begin(), id.end(), 0);
    while (!sta.empty()) sta.pop();
    insta.resize(n+1);
    fill(insta.begin(), insta.end(), 0);
    edcc = 0;
}

void add(int a, int b, int id) {
    if (a != b) {
        G[a].push_back(make_pair(b, id));
        G[b].push_back(make_pair(a, id));
    }
}

void tarjan(int now, int fa, int reid) {
    // dbg("tarjan", now);
    dfn[now] = ++clk;
    low[now] = dfn[now];
    insta[now] = 1;
    sta.push(now);
    for (const pii &e:G[now]) {
        int nt = e.first, eid = e.second;
        if (eid == reid) continue;
        if (!dfn[nt]) {
            tarjan(nt, now, eid);
            low[now] = min(low[nt], low[now]);
        } else if (insta[nt]) 
            low[now] = min(dfn[nt], low[now]);
    }
    
    if (dfn[now] == low[now]) {
        ++edcc;
        while (!sta.empty()) {
            int v = sta.top();
            id[v] = edcc;
            insta[v] = 0;
            sta.pop();
            if (v == now) break;   
        }
    }
}
void go(int n) {
    FOR (i, 0, sz(u)) {
        add(u[i], v[i], i);
    }
    FOR (i, 1, n+1) {
        if (!dfn[i]) {
            if (!sta.empty()) {
                while(1){}
            }
            tarjan(i, i, -1);
        }
    }
}
}

```
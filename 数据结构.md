# 数据结构

## Hash

### 矩阵 Hash

原矩阵 $s$ 中查找目标矩阵 $a$ 的出现次数

```c++
#define ULL unsigned long long
const ULL Base1=2007;
const ULL Base2=2009;
int test,n,m,x,y;
char s[2005][2005],a[2005][2005];
ULL ans,temp[2005][2005],Temp[2005][2005];

ULL Gethash()
{
    ULL c,sum=0;
    for(int i=0;i<x;i++)
    {
        c=0;
        for(int j=0;j<y;j++)
            c=c*Base1+a[i][j];
        sum=sum*Base2+c;
    }
    return sum;
}

void init()
{
    ULL t=1,c;
    for(int i=0;i<y;i++) t*=Base1;
    for(int i=0;i<n;i++)
    {
        c=0;
        for(int j=0;j<y;j++)
            c=c*Base1+s[i][j];
        temp[i][y-1]=c;
        for(int j=y;j<m;j++)
            temp[i][j]=temp[i][j-1]*Base1-s[i][j-y]*t+s[i][j];
    }
}

int GetAns(ULL Hash)
{
    ULL t=1,c;
    int ans=0;
    for(int i=0;i<x;i++) t*=Base2;
    for(int i=y-1;i<m;i++)
    {
        c=0;
        for(int j=0;j<x;j++) c=c*Base2+temp[j][i];
        Temp[x-1][i]=c;
        if(c==Hash) ans++;
        for(int j=x;j<n;j++)
        {
            Temp[j][i]=Temp[j-1][i]*Base2-temp[j-x][i]*t+temp[j][i];
            if(Temp[j][i]==Hash) ans++;
        }
    }
    return ans;
}

int main()
{
    scanf("%d%d%d%d",&x,&y,&n,&m);
    for(int i=0;i<x;i++)
        scanf("%s",a[i]);
    for(int i=0;i<n;i++)
        scanf("%s",s[i]);
    ULL Hash=Gethash();
    init();
    ans=GetAns(Hash);
    printf("%d\n",ans);
    return 0;
}
```

## 线段树

### 两延迟标记

change0区间置0，change1区间加1，query询问区间和

```c++
struct Data
{
    int tag,tag0,sum;
}tree[40100];

void build(int l,int r,int x)
{
    tree[x].tag=-1;tree[x].sum=0;tree[x].tag0=0;
    if (l==r) return ;
    int mid=l+r>>1;
    build(l,mid,x<<1);build(mid+1,r,x<<1|1);
}

void Pushdown(int x,int l,int r)
{
    if (tree[x].tag==-1) return ;
    int mid=l+r>>1;
    if (tree[x].tag0==1)
    {
        tree[x<<1].tag0=1;
        tree[x<<1|1].tag0=1;
        tree[x<<1].tag=tree[x].tag;
        tree[x<<1|1].tag=tree[x].tag;
        tree[x<<1].sum=tree[x].tag*(mid-l+1);
        tree[x<<1|1].sum=tree[x].tag*(r-mid);
        tree[x].tag=-1;tree[x].tag0=0;
    }
    else
    {
        if (tree[x<<1].tag==-1) tree[x<<1].tag=tree[x].tag;
        else tree[x<<1].tag+=tree[x].tag;
        if (tree[x<<1|1].tag==-1) tree[x<<1|1].tag=tree[x].tag;
        else tree[x<<1|1].tag+=tree[x].tag;
        tree[x<<1].sum+=tree[x].tag*(mid-l+1);
        tree[x<<1|1].sum+=tree[x].tag*(r-mid);
        tree[x].tag=-1;
    }
}

void change0(int lq,int rq,int l,int r,int x)
{
    if (lq<=l&&rq>=r)
    {
        tree[x].tag=0;tree[x].sum=0;tree[x].tag0=1;
        return ;
    }
    Pushdown(x,l,r);
    int mid=l+r>>1;
    if (lq<=mid) change0(lq,rq,l,mid,x<<1);
    if (rq>mid) change0(lq,rq,mid+1,r,x<<1|1);
    tree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;
}

void change1(int lq,int rq,int l,int r,int x)
{
    if (lq<=l&&rq>=r)
    {
        if (tree[x].tag==-1) tree[x].tag=1;else tree[x].tag++;
        tree[x].sum+=r-l+1;
        return ;
    }
    Pushdown(x,l,r);
    int mid=l+r>>1;
    if (lq<=mid) change1(lq,rq,l,mid,x<<1);
    if (rq>mid) change1(lq,rq,mid+1,r,x<<1|1);
    tree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;
}

int query(int lq,int rq,int l,int r,int x)
{
    if (lq<=l&&rq>=r) return tree[x].sum;
    Pushdown(x,l,r);
    int mid=l+r>>1,ans=0;
    if (lq<=mid) ans+=query(lq,rq,l,mid,x<<1);
    if (rq>mid) ans+=query(lq,rq,mid+1,r,x<<1|1);
    tree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;
    return ans;
}
```

## 树状数组

### 区间加区间和

```c++
struct bit
{
    int c[maxn],cc[maxn];
    void add(int x,int v)
    {
        for (int i=x;i<=n;i+=i&-i)
            c[i]+=v,cc[i]+=x*v;
    }
    void add(int l,int r,int v){add(l,v);add(r+1,-v);}
    int sum(int x)
    {
        int ret=0;
        for (int i=x;i;i-=i&-i)
            ret+=(x+1)*c[i]-cc[i];
        return ret;
    }
    int sum(int l,int r){return sum(r)-sum(l-1);}
}
```

## 倍增算法

### 树上 lca 倍增

```c++
#define MAXN 100010
struct LCA
{
    int n,m,S,c[MAXN],h[MAXN],to[MAXN*2],ne[MAXN*2],d[MAXN],p[MAXN*2][20];
    void dfs(int u)
    {
        c[u]=1;
        for (int i=h[u];i!=-1;i=ne[i])
        {
            if (!d[to[i]])
            {
                d[to[i]]=d[u]+1;
                p[to[i]][0]=u;
                dfs(to[i]);
                c[u]+=c[to[i]];
            }
        }
    }
    void solve()
    {
        for (int j=1;(1<<j)<=n;j++)
            for (int i=1;i<=n;i++)
                if (p[i][j-1]!=-1) p[i][j]=p[p[i][j-1]][j-1];
    }
    int lca(int x,int y)
    {
        if (d[x]<d[y]) swap(x,y);
        int i;
        for (i=0;(1<<i)<=d[x];i++);i--;
        for (int j=i;j>=0;j--)
            if (d[x]-(1<<j)>=d[y]) x=p[x][j];
        if (x==y) return x;
        for (int j=i;j>=0;j--)
            if (p[x][j]!=-1 && p[x][j]!=p[y][j])
                x=p[x][j],y=p[y][j];
        return p[x][0];
    }
    void Add(int x,int y)
    {
        S++;to[S]=x;ne[S]=h[y];h[y]=S;
        S++;to[S]=y;ne[S]=h[x];h[x]=S;
    }
    int Find(int x,int y)
    {
        y=d[x]-y;
        int i;
        for (i=0;(1<<i)<=d[x];i++);i--;
        for (int j=i;j>=0;j--)
            if (d[x]-(1<<j)>=y) x=p[x][j];
        return x;
    }
    void pre(int root)
    {
        d[root]=1;dfs(root);solve();
    }
    void init(int _n)
    {
        memset(h,-1,sizeof(h));
        memset(d,0,sizeof(d));
        S=0;this->n=_n;this->m=_n-1;
    }
}lca;
```

## CDQ 分治

### 三维偏序

第一维排序以后不再考虑，第二维利用归并排序，第三维用数据结构维护

* 注意数据结构不要 memset ，手动回撤操作

二位数点问题

```c++
int n,m,k,K,b[600010],c[600010];
LL ans;
struct data
{
    int x,r,f;
}a[100010];
struct query
{
    int l,r,op,le;
    query(int a=0,int b=0,int c=0,int d=0):l(a),r(b),op(c),le(d){}
}q[600010],temp[600010];

void add(int x,int y)
{
    for (;x<=600000;x+=x&-x) c[x]+=y;
}

int sum(int x)
{
    int ans=0;
    for (;x;x-=x&-x) ans+=c[x];
    return ans;
}

int Hash(int x)
{
    return lower_bound(b+1,b+1+K,x)-b;
}

void move(query &x,query y)
{
    x.l=y.l;x.r=y.r;x.op=y.op;x.le=y.le;
}

void cdq(int l,int r)
{
    if (l==r) return ;
    int mid=l+r>>1;
    cdq(l,mid);cdq(mid+1,r);
    for (int i=l;i<=r;i++)//标记左边的操作
        if (i<=mid) q[i].le=1;else q[i].le=0; 
    int x=l,y=mid+1,s=0;
    while(1)//归并排序
    {
        if (x<=mid&&(y>r||q[x].l<=q[y].l)) move(temp[++s],q[x]),x++;
        else if (y<=r) move(temp[++s],q[y]),y++;
        else break;
    }
    s=0;
    for (int i=l;i<=r;i++)
    {
        move(q[i],temp[++s]);
        if (temp[s].le==1)//处理左边的操作
        {
            if (temp[s].op==2) add(Hash(temp[s].r),1);
            //printf("+ %d(%d)\n",Hash(temp[s].r),temp[s].r);
        }
        else//处理右边的询问
        {
            if (temp[s].op!=2) ans+=(LL)temp[s].op*sum(Hash(temp[s].r));
            //printf("ans+=%d*%d\n",temp[s].op,sum(Hash(temp[s].r)));
        }
    }
    s=1;
    for (int i=l;i<=r;i++,s++)
        if (temp[s].le==1&&temp[s].op==2) add(Hash(temp[s].r),-1);
}

int main()
{
    m=0;K=0;
    for(int i=1;i<=n;i++)
    {
        q[++m]=query(a-1,b-1,1);
        q[++m]=query(x,y,1);
        q[++m]=query(a-1,y,-1);
        q[++m]=query(x,b-1,-1);//查询子矩阵 (a,b)-(x,y)
        q[++m]=query(x,y,2);//修改位置 (x,y)
        b[++K]=x;//离散
    }
    sort(b+1,b+1+K);
    K=unique(b+1,b+1+K)-b-1;
    memset(c,0,sizeof(c));
    cdq(1,m);
    print(ans),puts("");
    return 0;
}
```
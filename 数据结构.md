# 数据结构

## 线段树

### 两延迟标记

change0区间置0，change1区间加1，query询问区间和

```c++
struct Data
{
    int tag,tag0,sum;
}tree[40100];

void build(int l,int r,int x)
{
    tree[x].tag=-1;tree[x].sum=0;tree[x].tag0=0;
    if (l==r) return ;
    int mid=l+r>>1;
    build(l,mid,x<<1);build(mid+1,r,x<<1|1);
}

void Pushdown(int x,int l,int r)
{
    if (tree[x].tag==-1) return ;
    int mid=l+r>>1;
    if (tree[x].tag0==1)
    {
        tree[x<<1].tag0=1;
        tree[x<<1|1].tag0=1;
        tree[x<<1].tag=tree[x].tag;
        tree[x<<1|1].tag=tree[x].tag;
        tree[x<<1].sum=tree[x].tag*(mid-l+1);
        tree[x<<1|1].sum=tree[x].tag*(r-mid);
        tree[x].tag=-1;tree[x].tag0=0;
    }
    else
    {
        if (tree[x<<1].tag==-1) tree[x<<1].tag=tree[x].tag;
        else tree[x<<1].tag+=tree[x].tag;
        if (tree[x<<1|1].tag==-1) tree[x<<1|1].tag=tree[x].tag;
        else tree[x<<1|1].tag+=tree[x].tag;
        tree[x<<1].sum+=tree[x].tag*(mid-l+1);
        tree[x<<1|1].sum+=tree[x].tag*(r-mid);
        tree[x].tag=-1;
    }
}

void change0(int lq,int rq,int l,int r,int x)
{
    if (lq<=l&&rq>=r)
    {
        tree[x].tag=0;tree[x].sum=0;tree[x].tag0=1;
        return ;
    }
    Pushdown(x,l,r);
    int mid=l+r>>1;
    if (lq<=mid) change0(lq,rq,l,mid,x<<1);
    if (rq>mid) change0(lq,rq,mid+1,r,x<<1|1);
    tree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;
}

void change1(int lq,int rq,int l,int r,int x)
{
    if (lq<=l&&rq>=r)
    {
        if (tree[x].tag==-1) tree[x].tag=1;else tree[x].tag++;
        tree[x].sum+=r-l+1;
        return ;
    }
    Pushdown(x,l,r);
    int mid=l+r>>1;
    if (lq<=mid) change1(lq,rq,l,mid,x<<1);
    if (rq>mid) change1(lq,rq,mid+1,r,x<<1|1);
    tree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;
}

int query(int lq,int rq,int l,int r,int x)
{
    if (lq<=l&&rq>=r) return tree[x].sum;
    Pushdown(x,l,r);
    int mid=l+r>>1,ans=0;
    if (lq<=mid) ans+=query(lq,rq,l,mid,x<<1);
    if (rq>mid) ans+=query(lq,rq,mid+1,r,x<<1|1);
    tree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;
    return ans;
}
```

## 倍增算法

### 树上 lca 倍增

```c++
#define MAXN 100010
struct LCA
{
    int n,m,S,c[MAXN],h[MAXN],to[MAXN*2],ne[MAXN*2],d[MAXN],p[MAXN*2][20];
    void dfs(int u)
    {
        c[u]=1;
        for (int i=h[u];i!=-1;i=ne[i])
        {
            if (!d[to[i]])
            {
                d[to[i]]=d[u]+1;
                p[to[i]][0]=u;
                dfs(to[i]);
                c[u]+=c[to[i]];
            }
        }
    }
    void solve()
    {
        for (int j=1;(1<<j)<=n;j++)
            for (int i=1;i<=n;i++)
                if (p[i][j-1]!=-1) p[i][j]=p[p[i][j-1]][j-1];
    }
    int lca(int x,int y)
    {
        if (d[x]<d[y]) swap(x,y);
        int i;
        for (i=0;(1<<i)<=d[x];i++);i--;
        for (int j=i;j>=0;j--)
            if (d[x]-(1<<j)>=d[y]) x=p[x][j];
        if (x==y) return x;
        for (int j=i;j>=0;j--)
            if (p[x][j]!=-1 && p[x][j]!=p[y][j])
                x=p[x][j],y=p[y][j];
        return p[x][0];
    }
    void Add(int x,int y)
    {
        S++;to[S]=x;ne[S]=h[y];h[y]=S;
        S++;to[S]=y;ne[S]=h[x];h[x]=S;
    }
    int Find(int x,int y)
    {
        y=d[x]-y;
        int i;
        for (i=0;(1<<i)<=d[x];i++);i--;
        for (int j=i;j>=0;j--)
            if (d[x]-(1<<j)>=y) x=p[x][j];
        return x;
    }
    void pre(int root)
    {
        d[root]=1;dfs(root);solve();
    }
    void init(int _n)
    {
        memset(h,-1,sizeof(h));
        memset(d,0,sizeof(d));
        S=0;this->n=_n;this->m=_n-1;
    }
}lca;
```
